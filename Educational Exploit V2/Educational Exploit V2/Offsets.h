#pragma once
#include <stdexcept>
#include <tuple>
#include <typeinfo>
#include <windows.h>
#include <strsafe.h>
#include <string>
#include <iostream>
#include <thread>
#include <vector>

#include "RetCheck.h"


#define R_LUA_TNONE (-1)
#define R_LUA_TNIL 0
#define R_LUA_TLIGHTUSERDATA 1
#define R_LUA_TNUMBER 2
#define R_LUA_TBOOLEAN 3
#define R_LUA_TSTRING 4
#define R_LUA_TTHREAD 5
#define R_LUA_TFUNCTION 6
#define R_LUA_TTABLE 7
#define R_LUA_TUSERDATA 8
#define R_LUA_TPROTO 9
#define R_LUA_TUPVALUE 10

/*Eternals V3 RetCheck*/
namespace Retcheck
{
	DWORD Unprotect(DWORD addr, bool mode)
	{
		if (mode)
			return Ret::unprotect<DWORD>((BYTE*)addr);

		BYTE* tAddr = (BYTE*)addr;
		do
		{
			tAddr += 16;
		} while (!(tAddr[0] == 0x55 && tAddr[1] == 0x8B && tAddr[2] == 0xEC));

		DWORD funcSz = tAddr - (BYTE*)addr;

		PVOID nFunc = VirtualAlloc(NULL, funcSz, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (nFunc == NULL)
			return addr;

		memcpy(nFunc, (void*)addr, funcSz);

		BYTE* pos = (BYTE*)nFunc;
		BOOL valid = false;
		do
		{
			if (pos[0] == 0x72 && pos[2] == 0xA1 && pos[7] == 0x8B) {
				*(BYTE*)pos = 0xEB;

				DWORD cByte = (DWORD)nFunc;
				do
				{
					if (*(BYTE*)cByte == 0xE8)
					{
						DWORD oFuncPos = addr + (cByte - (DWORD)nFunc);
						DWORD oFuncAddr = (oFuncPos + *(DWORD*)(oFuncPos + 1)) + 5;

						if (oFuncAddr % 16 == 0)
						{
							DWORD relativeAddr = oFuncAddr - cByte - 5;
							*(DWORD*)(cByte + 1) = relativeAddr;

							cByte += 4;
						}
					}

					cByte += 1;
				} while (cByte - (DWORD)nFunc < funcSz);

				valid = true;
			}
			pos += 1;
		} while ((DWORD)pos < (DWORD)nFunc + funcSz);

		if (!valid)
		{
			VirtualFree(nFunc, funcSz, MEM_RELEASE);
			return addr;
		}

		return (DWORD)nFunc;
	}
}



DWORD unprotect(DWORD addr)
{
	BYTE* tAddr = (BYTE*)addr;
	do
	{
		tAddr += 16;
	} while (!(tAddr[0] == 0x55 && tAddr[1] == 0x8B && tAddr[2] == 0xEC));

	DWORD funcSz = tAddr - (BYTE*)addr;

	PVOID nFunc = VirtualAlloc(NULL, funcSz, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (nFunc == NULL)
		return addr;

	memcpy(nFunc, (void*)addr, funcSz);

	BYTE* pos = (BYTE*)nFunc;
	BOOL valid = false;
	do
	{
		if (pos[0] == 0x72 && pos[2] == 0xA1 && pos[7] == 0x8B) {
			*(BYTE*)pos = 0xEB;

			DWORD cByte = (DWORD)nFunc;
			do
			{
				if (*(BYTE*)cByte == 0xE8)
				{
					DWORD oFuncPos = addr + (cByte - (DWORD)nFunc);
					DWORD oFuncAddr = (oFuncPos + *(DWORD*)(oFuncPos + 1)) + 5;

					if (oFuncAddr % 16 == 0)
					{
						DWORD relativeAddr = oFuncAddr - cByte - 5;
						*(DWORD*)(cByte + 1) = relativeAddr;

						cByte += 4;
					}
				}

				cByte += 1;
			} while (cByte - (DWORD)nFunc < funcSz);

			valid = true;
		}
		pos += 1;
	} while ((DWORD)pos < (DWORD)nFunc + funcSz);

	if (!valid)
	{
		VirtualFree(nFunc, funcSz, MEM_RELEASE);
		return addr;
	}

	return (DWORD)nFunc;
}

typedef DWORD _DWORD;


union r_l_Value
{
	int b;
	double n;
	void* p;
	void* gc;
};

struct r_l_TValue
{
	r_l_Value value;
	int tt;
};

void fakeChain(DWORD* chain)
{
	chain[1] = 0x1555555;
	if ((((DWORD*)chain[0])[1]) != NULL) {
		((DWORD*)chain[0])[1] = 0x1555555;
	}
}
void restoreChain(DWORD* chain, DWORD unk, DWORD nextUnk)
{
	chain[1] = unk;
	if ((((DWORD*)chain[0])[1]) != NULL) {
		((DWORD*)chain[0])[1] = nextUnk;
	}
}

#define R_LUA_REGISTRYINDEX 0xFFFFD8F0
#define ASLR(OFFSET) (OFFSET - 0x400000 + (DWORD)GetModuleHandle(NULL))

DWORD ScriptContext;
DWORD lua_State;
int top = 24, base = 12;


DWORD ScriptContextVFT_Addy = ASLR(0x18C2504);

DWORD GetField_Addy = (0x7eFC80);  //scanned
DWORD SetField_Addy = (0x7f1A90); //scanned
DWORD GetMetaTable_Addy = (0x7eFF60);  //scanned
DWORD ToLString_Addy = (0x7f20c0); //scanned

DWORD PushNumber_Addy = (0x7f0fd0); //scanned
DWORD PushLightUserData_Addy = (0x7f0e40); //scanned
DWORD PushCClosure_Addy = (0x7f0BD0); //scanned

DWORD ToNumber_Addy = (0x7f23B0); //scanned
DWORD ToBoolean_Addy = (0x7f2000); //scanned

DWORD PCall_Addy = (0x7f0a80); //scanned
DWORD GetTop_Addy = (0x7f0190);
DWORD NewLStr_Addy = (0x7eb690); //scanned
DWORD Index2_Addy = (0x7e7510); //scanned
DWORD Next_Addy = (0x7f0900);

typedef void(__fastcall* XR_GetField)(DWORD RLS, int idx, const char *k);
typedef int(__stdcall *XR_SetField)(DWORD RLS, int idx, const char *k);

typedef void*(__fastcall *XR_GetMetaTable)(DWORD RLS, int idx);
typedef char*(__stdcall* XR_TolString)(DWORD RLS, int idx, size_t *size);

typedef double(__stdcall* XR_PushNumber)(DWORD RLS, double idx);
typedef void(__cdecl *XR_PushLightUserData)(DWORD RLS, void* p);
typedef void(__fastcall * XR_PushCClosure)(DWORD RLS, const void* fn, int non);

typedef double(__cdecl * XR_ToNumber)(DWORD RLS, int idx);
typedef bool(__cdecl* XR_ToBoolean)(DWORD RLS, bool idx);

typedef int(__cdecl* XR_GetTop)(DWORD RLS);
typedef int(__cdecl* XR_PCall)(DWORD RLS, DWORD nargs, DWORD nresults, DWORD errfunc);
typedef int(__stdcall *XR_NewLStr)(DWORD RLS, const char *str, size_t l);
typedef r_l_TValue*(__cdecl *XR_Index2)(int lst, int idx);
typedef DWORD(__cdecl* XR_Next)(DWORD RLS, int idx);


XR_GetField r_l_getfield = (XR_GetField)(unprotect(ASLR(GetField_Addy)));
XR_SetField r_l_setfield = (XR_SetField)(unprotect(ASLR(SetField_Addy)));


XR_TolString r_l_tolstring = (XR_TolString)(unprotect(ASLR(ToLString_Addy)));
XR_GetMetaTable r_l_getmetatable = (XR_GetMetaTable)(unprotect(ASLR(GetMetaTable_Addy)));

XR_PushNumber r_l_pushnumber = (XR_PushNumber)(unprotect(ASLR(PushNumber_Addy)));
XR_PushLightUserData r_l_pushlightuserdata = (XR_PushLightUserData)(unprotect(ASLR(PushLightUserData_Addy)));
XR_PushCClosure rpushcclosure = (XR_PushCClosure)(unprotect(ASLR(PushCClosure_Addy)));

XR_ToNumber r_l_tonumber = (XR_ToNumber)(ASLR(ToNumber_Addy));
XR_ToBoolean r_l_toboolean = (XR_ToBoolean)(ASLR(ToBoolean_Addy));

XR_GetTop r_l_gettop = (XR_GetTop)ASLR(GetTop_Addy);
XR_PCall r_l_pcall = (XR_PCall)Retcheck::Unprotect(ASLR(PCall_Addy), true);
XR_NewLStr r_l_newlstr = (XR_NewLStr)ASLR(NewLStr_Addy);
XR_Index2 r_l_index2 = (XR_Index2)ASLR(Index2_Addy);
XR_Next r_l_next = (XR_Next)(unprotect(ASLR(Next_Addy)));






/*Lua Macros In RLua*/

#define r_l_pop(rL,n)		r_l_settop(rL, -(n)-1)
#define r_l_getglobal(rL,s)	r_l_getfield(rL, -10002, (s))
#define r_l_createnewtable(rL) r_l_createtable(rL, 0, 0)
#define r_l_tostring(rL,i)	r_l_tolstring(rL, (i), NULL)



/*Inlined Functions*/

void r_l_pushnil(DWORD a1) {
	*(_DWORD *)(*(_DWORD *)(a1 + top) + 8) = 0;
	*(_DWORD *)(a1 + top) += 16;
}

void r_l_pushboolean(DWORD a1, int a2) {
	_DWORD *v2;
	v2 = *(_DWORD **)(a1 + top);
	*v2 = a2 != 0;
	v2[2] = 3;
	*(_DWORD *)(a1 + top) += 16;
}

void r_l_pushstring(int rState, const char *s) {
	int v3 = *(DWORD *)(rState + top);
	*(DWORD *)v3 = r_l_newlstr(rState, s, strlen(s));
	*(DWORD *)(v3 + 8) = R_LUA_TSTRING;
	*(DWORD *)(rState + top) += 16;
}

void r_l_settop(int a1, int a2) {
	int i;
	if (a2 < 0)
	{
		*(_DWORD *)(a1 + top) += 16 * a2 + 16;
	}
	else
	{
		for (i = 16 * a2; *(_DWORD *)(a1 + top) < (unsigned int)(i + *(_DWORD *)(a1 + base)); *(_DWORD *)(a1 + top) += 16)
			*(_DWORD *)(*(_DWORD *)(a1 + top) + 8) = 0;
		*(_DWORD *)(a1 + top) = i + *(_DWORD *)(a1 + base);
	}
}


void r_l_pushvalue(DWORD a1, int a2)
{
	r_l_TValue *p = r_l_index2(a1, a2);
	int v3 = *(DWORD *)(a1 + top);
	*(DWORD *)v3 = *(DWORD *)p;
	*(DWORD *)(v3 + 4) = *(DWORD *)(p + 4);
	*(DWORD *)(v3 + 8) = p->tt;
	*(DWORD *)(a1 + top) += 16;
}


inline void r_l_getservice(DWORD state, const char* s)
{
	r_l_getfield(lua_State, -10002, "game");
	r_l_getfield(lua_State, -1, "GetService");
	r_l_pushvalue(lua_State, -2);
	r_l_pushstring(lua_State, s);
	r_l_pcall(lua_State, 2, 1, 0);
}

void r_l_emptystack(DWORD luaState)
{
	r_l_settop(luaState, 0);
};

std::vector<DWORD> breakpoints;

#include <Windows.h>
#include <string>
#include <Psapi.h>


DWORD locateINT3() {
	DWORD _s = ASLR(0x400000);
	const char i3_8opcode[8] = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC };
	for (int i = 0; i < INT_MAX; i++) {
		if (memcmp((void*)(_s + i), i3_8opcode, sizeof(i3_8opcode)) == 0) {
			return (_s + i);
		}
	}
	return NULL;
}

int ChatHookHandler(DWORD rL)
{
	typedef int(*_handle)(DWORD);
	_handle handle = (_handle)(r_l_index2(rL, -10003)->value.p);
	return handle(rL);
}


LONG WINAPI ExceptionHandler(PEXCEPTION_POINTERS ex)
{
	switch (ex->ExceptionRecord->ExceptionCode)
	{
	case (DWORD)0x80000003L:
	{
		if (ex->ContextRecord->Eip == breakpoints[0])
		{
			ex->ContextRecord->Eip = (DWORD)(ChatHookHandler);
			return EXCEPTION_CONTINUE_EXECUTION;
		}
		return -1;
	}
	default: return 0;
	}
	return 0;
}


VOID EnableInt3BPHandler() {
	breakpoints.push_back(locateINT3());
	breakpoints.push_back(locateINT3());
	AddVectoredExceptionHandler(1, ExceptionHandler);
}


void pushcclosure(const void* func, DWORD n) {
	try {
		rpushcclosure(lua_State, func, n);
	}
	catch (...) {};
}

VOID PushCClosureBP(void* fn, DWORD n)
{
	r_l_pushlightuserdata(lua_State, fn);
	pushcclosure((const void*)(breakpoints[0]), n);
}